# Exercise 3.14
# Author: Noah Waterfield Price

from math import sqrt, exp, pi


def gauss(x, m=0, s=1):
    gaussian = 1 / (sqrt(2 * pi) * s) * exp(-0.5 * ((x - m) / s) ** 2)
    return gaussian
print '%8s' % 'x',
for x in range(-5, 6):
    print '%9d' % x,
print "\nGaussian",
for x in range(-5, 6):
    print '%.7f' % gauss(x),
# Exercise 3.24
# Author: Noah Waterfield Price

def heaviside(x):
    if x < 0:
        return 0
    elif x >= 0:
        return 1

print heaviside(-0.5)
print heaviside(0)
print heaviside(10)

"""
Sample run:
python Heaviside.py
0
1
1
"""
# Exercise 3.29
# Author: Noah Waterfield Price

def L(x, n):
    term = x / (1. + x)
    s = term
    for i in range(2, n + 1):
        # recursive relation between ci and c(i-1)
        term *= (i - 1.) / i * x / (1. + x)
        s += term
    value_of_sum = s
    first_neglected_term = term * n / (n + 1.) * x / (1. + x)
    from math import log
    exact_error = log(1 + x) - value_of_sum
    return value_of_sum, first_neglected_term, exact_error


def table(x):
    from math import log
    print '\nx=%g, ln(1+x)=%g' % (x, log(1 + x))
    for n in [1, 2, 10, 100, 500]:
        value, next, error = L(x, n)
        print 'n=%-4d %-10g  (next term: %8.2e  '\
              'error: %8.2e)' % (n, value, next, error)

table(10)
table(100)
table(1000)


def L2(x, epsilon=1.0E-6):
    term = x / (1. + x)
    s = term
    i = 1
    while abs(term) > epsilon:
        i += 1
        # recursive relation between ci and c(i-1)
        term *= (i - 1.) / i * x / (1. + x)
        s += term
    return s, i

print '\n\n'
from math import log
x = 10
for k in range(4, 14, 2):
    epsilon = 10 ** (-k)
    approx, n = L2(x, epsilon=epsilon)
    exact = log(1 + x)
    exact_error = exact - approx
    print 'epsilon: %5.0e, exact error: %8.2e, n=%d' % \
          (epsilon, exact_error, n)

"""
Sample run:
python L2_recursive.py

x=10, ln(1+x)=2.3979
n=1    0.909091    (next term: 4.13e-01  error: 1.49e+00)
n=2    1.32231     (next term: 2.50e-01  error: 1.08e+00)
n=10   2.17907     (next term: 3.19e-02  error: 2.19e-01)
n=100  2.39789     (next term: 6.53e-07  error: 6.59e-06)
n=500  2.3979      (next term: 3.65e-24  error: 5.77e-15)

x=100, ln(1+x)=4.61512
n=1    0.990099    (next term: 4.90e-01  error: 3.63e+00)
n=2    1.48025     (next term: 3.24e-01  error: 3.13e+00)
n=10   2.83213     (next term: 8.15e-02  error: 1.78e+00)
n=100  4.39574     (next term: 3.62e-03  error: 2.19e-01)
n=500  4.61395     (next term: 1.37e-05  error: 1.18e-03)

x=1000, ln(1+x)=6.90875
n=1    0.999001    (next term: 4.99e-01  error: 5.91e+00)
n=2    1.498       (next term: 3.32e-01  error: 5.41e+00)
n=10   2.919       (next term: 8.99e-02  error: 3.99e+00)
n=100  5.08989     (next term: 8.95e-03  error: 1.82e+00)
n=500  6.34928     (next term: 1.21e-03  error: 5.59e-01)



epsilon: 1e-04, exact error: 8.18e-04, n=55
epsilon: 1e-06, exact error: 9.02e-06, n=97
epsilon: 1e-08, exact error: 8.70e-08, n=142
epsilon: 1e-10, exact error: 9.20e-10, n=187
"""
# Exercise 3.31
# Author: Noah Waterfield Price

def L3(x, n=None, epsilon=None, return_n=False):
    if (n is None and epsilon is None) or \
            (n is not None and epsilon is not None):
        print 'Error: Either n or epsilon must be given (not both)'
    term = x / (1. + x)
    s = term
    if n is not None:
        for i in range(2, n + 1):
            # recursive relation between ci and c(i-1)
            term *= (i - 1.) / i * x / (1. + x)
            s += term
        return (s, n) if return_n is True else s
    elif epsilon is not None:
        i = 1
        while abs(term) > epsilon:
            i += 1
            # recursive relation between ci and c(i-1)
            term *= (i - 1.) / i * x / (1. + x)
            s += term
        return (s, i) if return_n is True else s

print L3(10, n=100)
print L3(10, n=1000, return_n=True)
print L3(10, epsilon=1e-10)
print L3(10, epsilon=1e-10, return_n=True)

"""
Sample run:
python L3_flexible.py
2.39788868474
(2.397895272798365, 1000)
2.39789527188
(2.397895271877886, 187
"""
# Exercise 3.17
# Author: Noah Waterfield Price

from scipy.integrate import quad
from scipy import exp, pi, cos, log, sqrt


def diff2(f, x, h=1E-6):
    r = (f(x - h) - 2 * f(x) + f(x + h)) / (h ** 2)
    return r


def adaptive_trapezint(f, a, b, eps=1E-4):
    ddf = []
    for i in range(101):
        ddf.append(abs(diff2(f, a + i * (b - a) / 100)))
    max_ddf = max(ddf)
    h = sqrt(12 * eps) * 1 / sqrt((b - a) * max_ddf)
    n = (b - a) / h
    s = (f(a) + f(b)) / 2
    for i in range(1, int(n)):
        s += f(a + i * h)
    s *= h
    return s


f1 = [exp, 0, log(3)]
f2 = (cos, 0, pi)

functions = [f1, f2]


def verify(f, a, b, n):
    exact = quad(f, a, b)[0]
    approx = adaptive_trapezint(f, a, b)
    error = abs(exact - approx)
    print 'The exact integral of %s between %.5f and %.5f is %.5f.\
     The approximate answer is %.5f giving an error of %.5f' \
        % (f.__name__, a, b, exact, approx, error)

for f in functions:
    verify(f[0], f[1], f[2], 10)

"""
Sample run:
python adaptive_trapezint.py
The exact integral of exp between 0.00000 and 1.09861 is 2.00000. The approximate answer is 1.96771 giving an error of 0.03229
The exact integral of cos between 0.00000 and 3.14159 is 0.00000. The approximate answer is 0.01467 giving an error of 0.01467
"""
# Exercise 3.9
# Author: Noah Waterfield Price

def area(vert):
    A = 0.5 * abs(vert[1][0] * vert[2][1] - vert[2][0] * vert[1][1] -
                  vert[0][0] * vert[2][1] + vert[2][0] * vert[0][1] +
                  vert[0][0] * vert[1][1] - vert[1][0] * vert[0][1])
    return A

v1 = (0, 0)
v2 = (1, 0)
v3 = (0, 2)
vertices = [v1, v2, v3]
triangle1 = area(vertices)

print 'Area of triangle is %.2f' % triangle1

"""
Sample run:
python area_triangle.py
Area of triangle is 1.00
"""
# Exercise 3.30
# Author: Noah Waterfield Price

def C(x, n):
    term = 1
    s = term
    for j in xrange(1, n + 1):
        term *= -x ** 2 / (2. * j * (2. * j - 1.))
        s += term
    return s


def table(x_list):
    from math import cos
    print '%7s %9s %9s %9s %9s %9s ' % ('x', 'n=5', 'n=25', 'n=50', 'n=100',
                                        'n=200')
    for x in x_list:
        errors = [x]
        for n in [5, 25, 50, 100, 200]:
            errors.append(cos(x) - C(x, n))
        print '%.4f %9.2e %9.2e %9.2e %9.2e %9.2e' % tuple(errors)

from math import pi
x_list = [4 * pi, 6 * pi, 8 * pi, 10 * pi]

table(x_list)
"""
Sample run:
python cossum.py
      x       n=5      n=25      n=50     n=100     n=200 
12.5664  1.61e+04  1.45e-11 -2.44e-12 -2.44e-12 -2.44e-12
18.8496  1.22e+06  2.28e-02  2.34e-10  2.34e-10  2.34e-10
25.1327  2.41e+07  6.58e+04 -2.40e-08 -2.40e-08 -2.40e-08
31.4159  2.36e+08  6.52e+09 -1.20e-04 -1.20e-04 -1.20e-04
"""
# slightly different to book - why??
# Exercise 3.34
# Author: Noah Waterfield Price

def count_pairs(dna, pair):
    pair = tuple(pair)
    i = 0
    for p1, p2 in zip(dna[:-1], dna[1:]):
        if (p1, p2) == pair:
            i += 1
    return i

dna = 'ATATGCGGACCTAT'
pair = 'AT'
print count_pairs(dna, pair)

"""
Sample run:
python count_pairs.py
3
"""
# Exercise 3.35
# Author: Noah Waterfield Price

def count_substr(dna, substr):
    i = 0
    for p in xrange(len(dna)):
        if dna[p] == substr[0]:
            if dna[p:p + len(substr)] == substr:
                i += 1
    return i

dna = 'ATATGCGGATACCTATA'
substr = 'ATA'
print count_substr(dna, substr)

"""
Sample run:
python count_substr.py
3
"""
# Exercise 3.16
# Author: Noah Waterfield Price

def diff(f, x, h=1E-6):
    return 1 / (2 * h) * (f(x + h) - f(x - h))

from math import exp, cos, sin, pi, log

f1 = lambda x: exp(x)
df1 = lambda x: exp(x)
f2 = lambda x: exp(-2 * x ** 2)
df2 = lambda x: -4 * x * exp(-2 * x ** 2)
f3 = lambda x: cos(x)
df3 = lambda x: -sin(x)
f4 = lambda x: log(x)
df4 = lambda x: 1 / x

funcs = [f1, f2, f3, f4]
diff_funcs = [df1, df2, df3, df4]
func_names = ['exp(x)', 'exp(-2x^2)', 'cos(x)', 'ln(x)']
values = [0, 0, 2 * pi, 1]

print '%10s %8s %8s %8s' % ('function', 'exact', 'approx', 'values')

for name, f, df, x in zip(func_names, funcs, diff_funcs, values):
    exact = df(x)
    approx = diff(f, x, h=0.01)
    error = abs(exact - approx)
    print '%10s %.6f %.6f %.6f' % (name, exact, approx, error)

"""
Sample run:
python diff_f.py
  function    exact   approx   values
    exp(x) 1.000000 1.000017 0.000017
exp(-2x^2) 0.000000 0.000000 0.000000
    cos(x) 0.000000 0.000000 0.000000
     ln(x) 1.000000 1.000033 0.000033
"""
# Exercise 3.15
# Author: Noah Waterfield Price

from math import log, pi


def egg(M, T_0, T_y):
    rho = 1.038 * 1000  # Egg density (kg m^-3_
    c = 3.7 * 1000  # Specific heat capacity (J kg^-1 K^-1)
    K = 0.54  # Thermal conductivity (W m^-1 K^-1)
    T_w = 373.15  # Boiling water temperature (K)
    t = M ** (2.0 / 3) * c * rho ** (1.0 / 3) / \
        (K * pi ** 2 * (4 * pi / 3) ** (2.0 / 3)) * \
        log(0.76 * (T_0 - T_w) / (T_y - T_w))
    return t

# Egg from fridge
T_0 = 277.15
# Soft boiled
T_y = 63 + 273.15
# Small egg
M = 0.047
t_small = egg(M, T_0, T_y)
# Large egg
M = 0.067
t_large = egg(M, T_0, T_y)
print 'From the fridge: to soft boil a small egg cook for %.2f minutes \
and a large egg for %.2f minutes.' % (t_small / 60, t_large / 60)

# Hard boiled
T_y = 70 + 273.15
# Small egg
M = 0.047
t_small = egg(M, T_0, T_y)
# Large egg
M = 0.067
t_large = egg(M, T_0, T_y)
print 'From the fridge: to hard boil a small egg cook for %.2f minutes \
and a large egg for %.2f minutes.' % (t_small / 60, t_large / 60)

# Egg at room temperature
T_0 = 293.15
# Soft boiled
T_y = 63 + 273.15
# Small egg
M = 0.047
t_small = egg(M, T_0, T_y)
# Large egg
M = 0.067
t_large = egg(M, T_0, T_y)
print 'At room temperature: to soft boil a small egg cook for %.2f minutes \
and a large egg for %.2f minutes.' % (t_small / 60, t_large / 60)

# Hard boiled
T_y = 70 + 273.15
# Small egg
M = 0.047
t_small = egg(M, T_0, T_y)
# Large egg
M = 0.067
t_large = egg(M, T_0, T_y)
print 'At room temperature: to hard boil a small egg cook for %.2f minutes \
and a large egg for %.2f minutes.' % (t_small / 60, t_large / 60)

"""
Sample run:
python egg_func.py
From the fridge: to soft boil a small egg cook for 3.99 minutes and a large egg for 5.05 minutes.
From the fridge: to hard boil a small egg cook for 5.22 minutes and a large egg for 6.61 minutes.
At room temperature: to soft boil a small egg cook for 2.92 minutes and a large egg for 3.69 minutes.
At room temperature: to hard boil a small egg cook for 4.15 minutes and a large egg for 5.25 minutes.
"""
# Exercise 3.1
# Author: Noah Waterfield Price

def C(F):
    C_val = (5. / 9) * (F - 32)
    F_val = (9.0 / 5) * C_val + 32
    return C_val if abs(F_val - F) < 1E-12 else 'Error'

print C(30)

"""
Sample run:
python f2c.py
-1.11111111111
"""
# Exercise 3.19
# Author: Noah Waterfield Price

def fact(n):
    ans = 1
    if n == 0 or n == 1:
        return ans
    else:
        while n > 0:
            ans *= n
            n -= 1
    return ans

print fact(5)

"""
Sample run:
python fact.py
120
"""
# Exercise 3.33
# Author: Noah Waterfield Price

def Sieve_of_Eratosthenes(N):
    numbers = range(2, N + 1)
    primes = []
    for p in xrange(len(numbers)):
        if numbers[p] != 0:
            primes.append(numbers[p])
            for i in xrange(numbers[p], N + 1, numbers[p]):
                numbers[i - 2] = 0
    return primes

primes100 = Sieve_of_Eratosthenes(100)
print primes100

"""
Sample run:
python find_primes.py
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
"""
# Exercise 3.12
# Author: Noah Waterfield Price

def hw1():
    return 'Hello, World!'


def hw2():
    print 'Hello, World!'


def hw3(s1, s2):
    print s1 + ', ' + s2


print hw1()
hw2()
hw3('Hello', 'World!')

"""
Sample run:
python hw_func.py
Hello, World!
Hello, World!
Hello, World!
"""
# Exercise 3.26
# Author: Noah Waterfield Price

def indicator1(x, a, b):
    if a <= x <= b:
        return 1
    else:
        return 0


def heaviside(x):
    if x < 0:
        return 0
    elif x >= 0:
        return 1


def indicator2(x, a, b):
    return heaviside(x - a) * heaviside(b - x)

a = -1
b = 2
for x in xrange(-3, 4):
    print indicator1(x, a, b) == indicator2(x, a, b)

"""
Sample run:
python indicator_func.py
True
True
True
True
True
True
True
"""
# Exercise 3.20
# Author: Noah Waterfield Price

from math import exp


def kinematics(x, t, dt=1E-6):
    v = (x(t + dt) - x(t - dt)) / (2 * dt)
    a = (x(t + dt) - 2 * x(t) + x(t - dt)) / dt ** 2
    x = x(t)
    return x, v, a

x = lambda t: exp(-(t - 4) ** 2)

print kinematics(x, 5, 1E-5)

"""
Sample run:
python kinematics1.py
(0.36787944117144233, -0.7357588822892723, 0.7357586762068989)
"""
# Exercise 3.21
# Author: Noah Waterfield Price

from math import cos, sin, pi


def kinematics(x, y, t, dt=1E-6):
    v = (x(t + dt) - x(t - dt)) / (2 * dt), (y(t + dt) - y(t - dt)) / (2 * dt)
    a = (x(t + dt) - 2 * x(t) + x(t - dt)) / \
        dt ** 2, (y(t + dt) - 2 * y(t) + y(t - dt)) / dt ** 2
    r = x(t), y(t)
    return r, v, a

t = 1
R = 1
w = 2 * pi
x = lambda t: R * w * cos(w * t)
y = lambda t: R * sin(w * t)

print kinematics(x, y, t, dt=1E-5)

"""
Sample run:
python kinematics2.py
((6.283185307179586, -2.4492935982947064e-16), (0.0, 6.283185303064565), (-248.05022036389343, 8.88164867172969e-06))
"""
# Exercise 3.22
# Author: Noah Waterfield Price

def maxmin(f, a, b, n=1000):
    max_f = max(f(a + i * (b - a) / 100) for i in range(101))
    min_f = min(f(a + i * (b - a) / 100) for i in range(101))
    return max_f, min_f
from math import cos, pi
print maxmin(cos, -pi / 2, 2 * pi, 100001)

"""
Sample run:
python maxmin_f.py
(1.0, -1.0)
"""
# Exercise 3.23
# Author: Noah Waterfield Price

def mymax(a):
    max_elem = a[0]
    for elem in a:
        if elem > max_elem:
            max_elem = elem
    return max_elem


def mymin(a):
    min_elem = a[0]
    for elem in a:
        if elem < min_elem:
            min_elem = elem
    return min_elem

print mymax([1, 5, 6, -2, 4, -7, -4, 2, 6, 5, 11, 3, 5])
print mymin([1, 5, 6, -2, 4, -7, -4, 2, 6, 5, 11, 3, 5])

"""
Sample run:
python maxmin_list.py
11
-7
"""
# Exercise 3.8
# Author: Noah Waterfield Price

from scipy.integrate import quad
from scipy import exp, pi, cos, sin, log


def midpointint(f, a, b, n):
    s = 0
    h = (b - a) / float(n)
    for i in range(1, n + 1):
        s += f(a - 0.5 * h + i * h)
    s *= h
    return s

f1 = [exp, 0, log(3)]
f2 = (cos, 0, pi)
f3 = (sin, 0, pi)
f4 = (sin, 0, pi / 2)

functions = [f1, f2, f3, f4]


def verify(f, a, b, n):
    exact = quad(f, a, b)[0]
    approx = midpointint(f, a, b, n)
    error = abs(exact - approx)
    print 'The exact integral of %s(x) between %.5f and %.5f is %.5f. \
           The approximate answer is %.5f giving an error of %.5f' \
        % (f.__name__, a, b, exact, approx, error)

for f in functions:
    verify(f[0], f[1], f[2], 10)

"""
Sample run:
python midpointint.py
The exact integral of exp(x) between 0.00000 and 1.09861 is 2.00000. The approximate answer is 1.99899 giving an error of 0.00101
The exact integral of cos(x) between 0.00000 and 3.14159 is 0.00000. The approximate answer is 0.00000 giving an error of 0.00000
The exact integral of sin(x) between 0.00000 and 3.14159 is 2.00000. The approximate answer is 2.00825 giving an error of 0.00825
The exact integral of sin(x) between 0.00000 and 1.57080 is 1.00000. The approximate answer is 1.00103 giving an error of 0.00103
"""
# Exercise 3.4
# Author: Noah Waterfield Price

def mysum(L):
    s = 0
    for e in L:
        s += e
    return s

print mysum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
print sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
"""
Sample run:
python mysum.py
55
55
"""
# Exercise 3.10
# Author: Noah Waterfield Price

from math import sqrt


def pathlength(x, y):
    L = 0
    for i in range(1, len(x)):
        dL_squared = (x[i] - x[i - 1]) ** 2 + (y[i] - y[i - 1]) ** 2
        L += sqrt(dL_squared)
    return L

points = [(1, 1), (2, 1), (1, 2), (1, 1)]

x = [points[i][0] for i in range(len(points))]
y = [points[i][1] for i in range(len(points))]

print pathlength(x, y)

"""
Sample run:
python pathlength.py
3.41421356237
"""
# Exercise 3.11
# Author: Noah Waterfield Price

from math import sin, cos, pi, sqrt


def pathlength(x, y):
    L = 0
    for i in range(1, len(x)):
        dL_squared = (x[i] - x[i - 1]) ** 2 + (y[i] - y[i - 1]) ** 2
        L += sqrt(dL_squared)
    return L


def points(N):
    x = [0.5 * cos(2 * pi * i / N) for i in range(N + 1)]
    y = [0.5 * sin(2 * pi * i / N) for i in range(N + 1)]
    return x, y

N_list = [2 ** k for k in range(2, 11)]

for N in N_list:
    x, y = points(N)
    approx = pathlength(x, y)
    print 'For %4d points on the circle, pi approximates to %.8f \
giving and error of %.8f' % \
        (N, approx, pi - approx)

"""
Sample run:
python pi_approx.py
For    4 points on the circle, pi approximates to 2.82842712 giving and error pf 0.31316553
For    8 points on the circle, pi approximates to 3.06146746 giving and error pf 0.08012519
For   16 points on the circle, pi approximates to 3.12144515 giving and error pf 0.02014750
For   32 points on the circle, pi approximates to 3.13654849 giving and error pf 0.00504416
For   64 points on the circle, pi approximates to 3.14033116 giving and error pf 0.00126150
For  128 points on the circle, pi approximates to 3.14127725 giving and error pf 0.00031540
For  256 points on the circle, pi approximates to 3.14151380 giving and error pf 0.00007885
For  512 points on the circle, pi approximates to 3.14157294 giving and error pf 0.00001971
For 1024 points on the circle, pi approximates to 3.14158773 giving and error pf 0.00000493
"""
# Exercise 3.27
# Author: Noah Waterfield Price

def piecewise(x, data):
    for i in range(len(data) - 1):
        if data[i][1] <= x < data[i + 1][1]:
            return data[i][0]

# need last pair to define final x interval
data = [(20, -2), (-1, 0), (0, 1), (4, 1.5), (-7, 4), (23, 6.3), (None, 7.5)]

for x in range(-1, 8):
    print piecewise(x, data)

"""
Sample run:
python piecewise_constant1.py
20
-1
0
4
4
-7
-7
-7
23
"""
# Exercise 3.28
# Author: Noah Waterfield Price

def heaviside1(x):
    if x < 0:
        return 0
    elif x >= 0:
        return 1

# need two step functions as conditions swap round when argument is -x


def heaviside2(x):
    if x >= 0:
        return 0
    elif x < 0:
        return 1


def indicator2(x, a, b):
    return heaviside1(x - a) * heaviside2(x - b)


def piecewise(x, data):
    s = 0
    for i in range(len(data) - 1):
        s += data[i][0] * indicator2(x, data[i][1], data[i + 1][1])
    return s

# need last pair to define final x interval
data = [(20, -2), (-1, 0), (0, 1), (4, 1.5), (-7, 4), (23, 6.3), (None, 7.5)]

for x in range(-1, 8):
    print piecewise(x, data)

"""
Sample run:
python piecewise_constant2.py
20
-1
0
4
4
-7
-7
-7
23
"""
# Exercise 3.18
# Author: Noah Waterfield Price

roots = [-1, 1, 2]


def poly(roots, x):
    p = 1
    for i in range(len(roots)):
        p *= (x - roots[i])
    return p

print poly(roots, 3)

"""
Sample run:
python polyprod.py
8
"""
# Exercise 3.3
# Author: Noah Waterfield Price

def roots(a, b, c):
    from cmath import sqrt
    q = sqrt(b * b - 4 * a * c)
    x1 = (-b + q) / (2 * a)
    x2 = (-b - q) / (2 * a)
    return x1, x2

print roots(1, 3, 2)
print roots(1, -2, 3)

"""
Sample run:
python roots_quadratic.py
((-1+0j), (-2+0j))
((1+1.4142135623730951j), (1-1.4142135623730951j))
"""
# Exercise 3.13
# Author: Noah Waterfield Price

from math import sin, pi


def S(t, n, T):
    s = 0
    for i in range(1, n + 1):
        s += 1.0 / (2 * i - 1) * sin(2 * (2 * i - 1) * pi * t / T)
    s *= 4 / pi
    return s


def f(t, T):
    if 0 < t < T / 2:
        ans = 1
    elif abs(t - T / 2) < 1E-14:
        ans = 0
    elif T / 2 < t < T:
        ans = -1
    else:
        print 'Error: t must be between 0 and T'
        ans = None
    return ans

n_list = [1, 3, 5, 10, 30, 100]
alpha_list = 0.01, 0.25, 0.49
T = 2 * pi
t_list = [2 * alpha * T for alpha in alpha_list]

for n in n_list:
    print 'n = %d' % n
    print '  Function t=%.2f*pi t=%.2f*pi t=%.2f*pi' % (0.01, 0.25, 0.49)
    print '%10s %.7f %.7f %.7f' % ('f(t, T)',
                                   f(t_list[0], T),
                                   f(t_list[1], T),
                                   f(t_list[2], T))
    print '%10s %.7f %.7f %.7f' % ('S(t, n, T)',
                                   S(t_list[0], n, T),
                                   S(t_list[1], n, T),
                                   S(t_list[2], n, T))
    print '%10s %.7f %.7f %.7f' % ('Error',
                                   abs(S(t_list[0], n, T) - f(t_list[0], T)),
                                   abs(S(t_list[0], n, T) - f(t_list[0], T)),
                                   abs(S(t_list[0], n, T) - f(t_list[0], T)))
    print ''

"""
Sample run:
python sinesum1.py
n = 1
  Function t=0.01*pi t=0.25*pi t=0.49*pi
   f(t, T) 1.0000000 0.0000000 -1.0000000
S(t, n, T) 0.1595792 0.0000000 -0.1595792
     Error 0.8404208 0.8404208 0.8404208

n = 3
  Function t=0.01*pi t=0.25*pi t=0.49*pi
   f(t, T) 1.0000000 0.0000000 -1.0000000
S(t, n, T) 0.4654944 0.0000000 -0.4654944
     Error 0.5345056 0.5345056 0.5345056

n = 5
  Function t=0.01*pi t=0.25*pi t=0.49*pi
   f(t, T) 1.0000000 0.0000000 -1.0000000
S(t, n, T) 0.7336510 0.0000000 -0.7336510
     Error 0.2663490 0.2663490 0.2663490

n = 10
  Function t=0.01*pi t=0.25*pi t=0.49*pi
   f(t, T) 1.0000000 0.0000000 -1.0000000
S(t, n, T) 1.1349367 0.0000000 -1.1349367
     Error 0.1349367 0.1349367 0.1349367

n = 30
  Function t=0.01*pi t=0.25*pi t=0.49*pi
   f(t, T) 1.0000000 0.0000000 -1.0000000
S(t, n, T) 0.9648738 0.0000000 -0.9648738
     Error 0.0351262 0.0351262 0.0351262

n = 100
  Function t=0.01*pi t=0.25*pi t=0.49*pi
   f(t, T) 1.0000000 0.0000000 -1.0000000
S(t, n, T) 0.9746817 0.0000000 -0.9746817
     Error 0.0253183 0.0253183 0.0253183
"""
# Exercise 3.25
# Author: Noah Waterfield Price

from math import sin, pi


def smoothed_Heaviside(x, e=1E-2):
    if x < -e:
        return 0
    elif -e <= x <= e:
        return 0.5 + x / (2 * e) + 1 / (2 * pi) * sin(pi * x / e)
    elif x > e:
        return 1

print smoothed_Heaviside(-1)
print smoothed_Heaviside(-0.01)
print smoothed_Heaviside(-0.001)
print smoothed_Heaviside(0.001)
print smoothed_Heaviside(0.01)
print smoothed_Heaviside(1)

"""
Sample run:
python smoothed_Heaviside.py
0
-1.94908591626e-17
0.400818417846
0.599181582154
1.0
1
"""
# Exercise 3.32
# Author: Noah Waterfield Price

data = [
    ('Alpha Centauri A',    4.3,  0.26,      1.56),
    ('Alpha Centauri B',    4.3,  0.077,     0.45),
    ('Alpha Centauri C',    4.2,  0.00001,   0.00006),
    ("Barnard's Star",      6.0,  0.00004,   0.0005),
    ('Wolf 359',            7.7,  0.000001,  0.00002),
    ('BD +36 degrees 2147', 8.2,  0.0003,    0.006),
    ('Luyten 726-8 A',      8.4,  0.000003,  0.00006),
    ('Luyten 726-8 B',      8.4,  0.000002,  0.00004),
    ('Sirius A',            8.6,  1.00,      23.6),
    ('Sirius B',            8.6,  0.001,     0.003),
    ('Ross 154',            9.4,  0.00002,   0.0005),
]


def print_table(data, mykey):
    print '-------------------------------------------------------------'
    print '%-19s %13s %13s %13s' % ('Star name', 'd_sun',
                                    'Brightness', 'Luminosity')
    print '-------------------------------------------------------------'
    for row in sorted(data, key=mykey):
        print '%-19s %13f %13f %13f' % row
    print '-------------------------------------------------------------\n'

print 'Sorted by star name'
print_table(data, lambda a: a[0])
print 'Sorted by distance to sun'
print_table(data, lambda a: a[1])

print 'Sorted by brightness'
print_table(data, lambda a: a[2])

print 'Sorted by luminosity'
print_table(data, lambda a: a[3])

"""
Sample run:
python sorted_stars_data.py
Sorted by star name
-------------------------------------------------------------
Star name                   d_sun    Brightness    Luminosity
-------------------------------------------------------------
Alpha Centauri A         4.300000      0.260000      1.560000
Alpha Centauri B         4.300000      0.077000      0.450000
Alpha Centauri C         4.200000      0.000010      0.000060
BD +36 degrees 2147      8.200000      0.000300      0.006000
Barnard's Star           6.000000      0.000040      0.000500
Luyten 726-8 A           8.400000      0.000003      0.000060
Luyten 726-8 B           8.400000      0.000002      0.000040
Ross 154                 9.400000      0.000020      0.000500
Sirius A                 8.600000      1.000000     23.600000
Sirius B                 8.600000      0.001000      0.003000
Wolf 359                 7.700000      0.000001      0.000020
-------------------------------------------------------------

Sorted by distance to sun
-------------------------------------------------------------
Star name                   d_sun    Brightness    Luminosity
-------------------------------------------------------------
Alpha Centauri C         4.200000      0.000010      0.000060
Alpha Centauri A         4.300000      0.260000      1.560000
Alpha Centauri B         4.300000      0.077000      0.450000
Barnard's Star           6.000000      0.000040      0.000500
Wolf 359                 7.700000      0.000001      0.000020
BD +36 degrees 2147      8.200000      0.000300      0.006000
Luyten 726-8 A           8.400000      0.000003      0.000060
Luyten 726-8 B           8.400000      0.000002      0.000040
Sirius A                 8.600000      1.000000     23.600000
Sirius B                 8.600000      0.001000      0.003000
Ross 154                 9.400000      0.000020      0.000500
-------------------------------------------------------------

Sorted by brightness
-------------------------------------------------------------
Star name                   d_sun    Brightness    Luminosity
-------------------------------------------------------------
Wolf 359                 7.700000      0.000001      0.000020
Luyten 726-8 B           8.400000      0.000002      0.000040
Luyten 726-8 A           8.400000      0.000003      0.000060
Alpha Centauri C         4.200000      0.000010      0.000060
Ross 154                 9.400000      0.000020      0.000500
Barnard's Star           6.000000      0.000040      0.000500
BD +36 degrees 2147      8.200000      0.000300      0.006000
Sirius B                 8.600000      0.001000      0.003000
Alpha Centauri B         4.300000      0.077000      0.450000
Alpha Centauri A         4.300000      0.260000      1.560000
Sirius A                 8.600000      1.000000     23.600000
-------------------------------------------------------------

Sorted by luminosity
-------------------------------------------------------------
Star name                   d_sun    Brightness    Luminosity
-------------------------------------------------------------
Wolf 359                 7.700000      0.000001      0.000020
Luyten 726-8 B           8.400000      0.000002      0.000040
Alpha Centauri C         4.200000      0.000010      0.000060
Luyten 726-8 A           8.400000      0.000003      0.000060
Barnard's Star           6.000000      0.000040      0.000500
Ross 154                 9.400000      0.000020      0.000500
Sirius B                 8.600000      0.001000      0.003000
BD +36 degrees 2147      8.200000      0.000300      0.006000
Alpha Centauri B         4.300000      0.077000      0.450000
Alpha Centauri A         4.300000      0.260000      1.560000
Sirius A                 8.600000      1.000000     23.600000
-------------------------------------------------------------
"""
# Exercise 3.2
# Author: Noah Waterfield Price

def sum_1_div_k(M=100):
    s = 0
    k = 1
    while k <= M:
        s += 1. / k
        k += 1
    print s

sum_1_div_k(3)

"""
Sample run:
python sum_func.py
1.83333333333
"""
# Exercise 3.7
# Author: Noah Waterfield Price

from scipy.integrate import quad
from scipy import exp, pi, cos, sin, log


def trapezint(f, a, b, n):
    s = (f(a) + f(b)) / 2
    h = (b - a) / float(n)
    for i in range(1, n):
        s += f(a + i * h)
    s *= h
    return s

f1 = [exp, 0, log(3)]
f2 = (cos, 0, pi)
f3 = (sin, 0, pi)
f4 = (sin, 0, pi / 2)

functions = [f1, f2, f3, f4]


def verify(f, a, b, n):
    exact = quad(f, a, b)[0]
    approx = trapezint(f, a, b, n)
    error = abs(exact - approx)
    print 'The exact integral of %s between %.5f and %.5f is %.5f. \
           The approximate answer is %.5f giving an error of %.5f' \
        % (f.__name__, a, b, exact, approx, error)

for f in functions:
    verify(f[0], f[1], f[2], 10)

"""
Sample run:
python trapezint.py
The exact integral of exp between 0.00000 and 1.09861 is 2.00000. The approximate answer is 2.00201 giving an error of 0.00201
The exact integral of cos between 0.00000 and 3.14159 is 0.00000. The approximate answer is 0.00000 giving an error of 0.00000
The exact integral of sin between 0.00000 and 3.14159 is 2.00000. The approximate answer is 1.98352 giving an error of 0.01648
The exact integral of sin between 0.00000 and 1.57080 is 1.00000. The approximate answer is 0.99794 giving an error of 0.00206
"""
# Exercise 3.5
# Author: Noah Waterfield Price

from scipy.integrate import quad
from scipy import exp, pi, cos, sin, log


def trapezint1(f, a, b):
    return (b - a) / 2. * (f(a) + f(b))

f1 = [exp, 0, log(3)]
f2 = (cos, 0, pi)
f3 = (sin, 0, pi)
f4 = (sin, 0, pi / 2)

functions = [f1, f2, f3, f4]


def verify(f, a, b):
    exact = quad(f, a, b)[0]
    approx = trapezint1(f, a, b)
    error = abs(exact - approx)
    print 'The exact integral of %s between %.5f and %.5f is %.5f. \
           The approximate answer is %.5f giving an error of %.5f' \
               % (f.__name__, a, b, exact, approx, error)

for f in functions:
    verify(f[0], f[1], f[2])

"""
Sample run:
python trapezint1.py
The exact integral of exp between 0.00000 and 1.09861 is 2.00000. The approximate answer is 2.19722 giving an error of 0.19722
The exact integral of cos between 0.00000 and 3.14159 is 0.00000. The approximate answer is 0.00000 giving an error of 0.00000
The exact integral of sin between 0.00000 and 3.14159 is 2.00000. The approximate answer is 0.00000 giving an error of 2.00000
The exact integral of sin between 0.00000 and 1.57080 is 1.00000. The approximate answer is 0.78540 giving an error of 0.21460
"""
# Exercise 3.6
# Author: Noah Waterfield Price

from scipy.integrate import quad
from scipy import exp, pi, cos, sin, log


def trapezint2(f, a, b):
    return (b - a) / 4. * (f(a) + 2 * f((a + b) / 2.) + f(b))

f1 = [exp, 0, log(3)]
f2 = (cos, 0, pi)
f3 = (sin, 0, pi)
f4 = (sin, 0, pi / 2)

functions = [f1, f2, f3, f4]


def verify(f, a, b):
    exact = quad(f, a, b)[0]
    approx = trapezint2(f, a, b)
    error = abs(exact - approx)
    print 'The exact integral of %s between %.5f and %.5f is %.5f. \
           The approximate answer is %.5f giving an error of %.5f' \
               % (f.__name__, a, b, exact, approx, error)

for f in functions:
    verify(f[0], f[1], f[2])

"""
Sample run:
python trapezint2.py
The exact integral of exp between 0.00000 and 1.09861 is 2.00000. The approximate answer is 2.05004 giving an error of 0.05004
The exact integral of cos between 0.00000 and 3.14159 is 0.00000. The approximate answer is 0.00000 giving an error of 0.00000
The exact integral of sin between 0.00000 and 3.14159 is 2.00000. The approximate answer is 1.57080 giving an error of 0.42920
The exact integral of sin between 0.00000 and 1.57080 is 1.00000. The approximate answer is 0.94806 giving an error of 0.05194
"""
